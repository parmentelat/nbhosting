#!/bin/bash
# -*- mode: shell-script -*-
#
# group all shell commands in a single file
# you can run any of the inside functions with e.g.
# nbh the-function the-arguments

ENGINE=podman

# terminology
# (*) course refers to a course name as found under NBHROOT/courses
# (*) student refers to a UNIX login name, and is identical
# to the names used under NBHROOT when referring to a student
# (*) container is the name of a container as per the container runtime
#
# conventions
# (*) functions designed to be exposed to the outside
#     are declared with @declare-subcommand
# (*) some other minor subcommands are available
#     they start with a lowercase, but are not declared
#     as subcommands
# (*) internal-only functions start with a dash -
#
#
# NOTES about systemd-nspawn:
#
# (*) there remains in here some leftovers of a rough attempt
#     that I made at using systemd-nspawn as a replacement to docker
#     this was never finished, although we were probably close
#     all this was commented off in Jan. 2018
# (*) in this approach we still used docker but just for doing image
#     snapshots
# (*) the IMAGES and MACHINES globals are only used for this
#     systemd-nspawn variant, which was never finished
#     although we were probably close
# (*) missing was a suitable strategy for setuid
#     as linux user namespaces looks a little overkill
# (*) using the same approach to setuids as the one eventually
#     adopted for docker (i.e. start-in-dir-as-uid) should probably
#     be rather straightforward with systemd-nspawn too
#
# NOTE about interactions between shell and python
# sometimes we need to probe for data that is in the python world
# for this we use django management commands, that are accessible from
# the shell as /usr/bin/nbh-manage, which is a simple copy of django/manage.py
# although eventually for static definitions we've gone for good old files
# for a quicker and safer mechanism, logger was clobbering output
########################################

# nbh-driver
COMMAND=$0

# the default value for the most crucial global
NBHROOT=${NBHROOT:-/nbhosting/current}

# SRCROOT may be passed to all commands
# with nbh -s <srcroot> the-function the-parameters
#
# from that location we will compute the path
# to sitesettings.sh that contains a bash version
# of the configuration initially made in sitesettings.py
# among others, sitesettings.sh defines nbhroot
#
function load-sitesettings() {
    local global_debug
    [ "$DEBUG" == "true-from-command-line" ] && global_debug=true
    local sitesettings=$NBHROOT/sitesettings.sh
    -echo-stderr LOADING sitesettings $sitesettings
    [ -f $sitesettings ] || -die "Cannot spot sitesettings.sh - aborting"
    source $sitesettings
    # for legacy, these are lowercase in sitesettings.py
    NBHROOT=$nbhroot
    # onother one we need here; command-line has precedence
    [ "$DEBUG" == "False" ] && DEBUG=
    [ -n "$global_debug" ] && DEBUG=true-from-command-line
    # yet another one
    [ -z "$container_max_memory" ] && container_max_memory="0"
}

### various timeouts
# format is ticks period
# so e.g. 10 0.3
# means 10s and retry every 300ms
#
# how long should we wait for the container to answer http
# trying to create 6 containers at the exact same time : 10s is not long enough
timeout_wait_for_http="30 .4"

# implementation note
#  don't do set -e, as it may cause the program to exit abruptly
# and we need to make sure we output exactly one line with 4 tokens

########## for listing available subcommands
SUBCOMMANDS=""
function @declare-subcommand() {
    subcommand=$1; shift
    SUBCOMMANDS="$SUBCOMMANDS $subcommand"
}

############################## helpers
function -echo-stderr() {
    local milli=$(date +"%N" | sed -e 's,\(...\).*,\1,')
    >&2 echo $(date "+%H:%M:%S").$milli "$@"
}

function -die() {
    -echo-stderr "$@"
    exit 1
}

########################################
# runtime
########################################

# create directory/ies leading to file <file>
function -mkdir-for-file-as-student () {
    [ "$#" -eq 2 ] || -die $FUNCNAME requires 2 args
    local filename="$1"; shift
    local login=$1; shift

    local dir=$(dirname "$filename")
    [ -d $dir ] || {
        -echo-stderr ID=$(id)
        -echo-stderr Creating directory $dir for "$filename"
        mkdir -p $dir
        -echo-stderr Giving $dir to $login
        chown $login:$login $dir
    }
}

# create symlink right where the notebook is, not only at the top
function -create-symlink-at-file () {
    [ "$#" -eq 3 ] || -die $FUNCNAME requires 3 args
    local filename="$1"; shift
    local localname="$1"; shift
    local destination="$1"; shift

    local dir=$(dirname "$filename")
    # the symlink should
    # be in dir/ (like filename)
    # be named localname
    # and point at destination
    local source="$dir/$localname"
    [ -h "$destination" ] || -echo-stderr creating static symlink "$destination"
    ln -sf "$destination" "$source"
}


############################## course management
function -compute-course-globals() {
    [ "$#" -eq 1 ] || -die $FUNCNAME requires 1 arg
    local course=$1; shift
    COURSE_git=$NBHROOT/courses-git/$course
    COURSE_notebooks=$NBHROOT/courses/$course
    COURSE_modules=$NBHROOT/modules/$course
    COURSE_static=$NBHROOT/static/$course
    COURSE_jupyter=$NBHROOT/jupyter/$course
    COURSE_raw=$NBHROOT/raw/$course
    COURSE_image=$NBHROOT/images/$course
    COURSE_build=$NBHROOT/builds/$course
    COURSE_droparea=$NBHROOT/droparea/$course
    COURSE_local=$NBHROOT/local/$course


#    # for systemd-nspawn
#    COURSE_ref=$MACHINES/$course.ref

# this is how the static mappings business is being exposed to bash
# from the django app
    COURSE_static_mappings=$(cat $COURSE_notebooks/.static-mappings 2> /dev/null)
    COURSE_static_toplevels=$(cat $COURSE_notebooks/.static-toplevels 2> /dev/null)
}


# clone from upstream git repo
# and updates the various parts accordingly

@declare-subcommand course-init
function course-init() {
    local USAGE="Usage: $COMMAND $FUNCNAME course giturl"
    [ "$#" -eq 2 ] || -die $USAGE

    local course=$1; shift
    local giturl=$1; shift

    -compute-course-globals $course

    [ -d $COURSE_git ] && -die "Course already present as $COURSE_git"

    echo ==========  $(date): course-init from $giturl
    local courses_git_parent=$(dirname $COURSE_git)
    mkdir -p $courses_git_parent
    cd $courses_git_parent
    echo In $(pwd) : running git clone $giturl $course
    git clone $giturl $course

}


##########
# fetch and reset from upstream git repo
# and updates the various parts accordingly
#
# note that this DOES NOT MERGE but instead does a reset --hard
# on the upstream commit; the remote is expected to be named 'origin'
###
@declare-subcommand course-update-from-git
function course-update-from-git() {
    local USAGE="Usage: $COMMAND $FUNCNAME course"

    [ "$#" -eq 1 ] || -die $USAGE

    course=$1; shift
    -compute-course-globals $course

    # check the course is known
    [ -d $COURSE_git ] || -die "Cannot find git repo $COURSE_git"
    # initialize
    [ -d $COURSE_notebooks ] || {
        echo Creating notebooks dir $COURSE_notebooks
        mkdir -p $COURSE_notebooks
    }

    rsync="rsync --recursive --copy-unsafe-links --perms --times --force --delete"

    [ -d $COURSE_git ] || -die "$FUNCNAME: $course has not git repo in $COURSE_git - aborting"

    echo ==========  $(date): update-course

    cd $COURSE_git
    echo "========== git fetch origin"
    git fetch origin

    local branch=$(git rev-parse --abbrev-ref HEAD)
    echo "========== git reset --hard origin/$branch"
    git reset --hard origin/$branch
    # this does not always show 3 commits
    # so let's be more vague about that
    echo "========== latest commits"
    git log --oneline "HEAD~~~..HEAD"
    echo "========== dealing with submodules"
    # might not be exactly needed anymore if we use subtrees instead
    git submodule init
    git submodule update

    echo "========== housekeeping"
    # create course dirs if needed
    for dir in $COURSE_notebooks $COURSE_modules $COURSE_static $COURSE_raw $COURSE_droparea; do
        [ -d $dir ] || { echo Creating $dir; mkdir -p $dir; }
    done

    # clear track caches
    rm -rf $COURSE_notebooks/.tracks.json

    ##### notebooks
    # temporary; making sure we do clean stuff up properly
    echo "========== syncing the notebooks area"
    rm -rf $COURSE_notebooks/*
    # xxx would be nice to use sitesettings.notebook_extensions
    $rsync --prune-empty-dirs --include='*.ipynb' --include='*.md' --include='*.py' --include='*/' --exclude='*' \
        $COURSE_git/ $COURSE_notebooks/
    ##### modules
    [ -d modules ] && { $rsync modules/ $COURSE_modules; chmod -R g-w,o-w $COURSE_modules; }
    ##### static
    for toplevel in $COURSE_static_toplevels; do
        if [ -e $toplevel ]; then
            echo "========== rsyncing static $toplevel"
            $rsync $toplevel $COURSE_static; chmod -R g-w,o-w $COURSE_static;
        else
            echo "========== skipped non-existent static $toplevel"
        fi
    done

    echo "========== syncing the jupyter area"
    --course-update-jupyter $course

    return 0

}

####################
function -check-course() {
    local course=$1; shift
    -compute-course-globals $course
    [ -d $COURSE_notebooks ] || -die "No such course $course"
}


##### jupyter
# 2023 06 new approach entirely
#   we take
# (1) the contents of jupyter/ (as shipped with the nbhosting repo)
#   and we overwrite that with
# (2) the contents of .nbhosting/jupyter/ if that exists in the repo
#   and finally we overwrite that with
# (3) the contents of jupyter_notebook_config.py
#    (as per local settings applied on jupyter_notebook_settings.py.in)
#
# note that
# * jupyter_notebook_config.py.in is actually expansed by the install script
# * for jupyter_notebook_config.py at least, we must ensure it is genuine
#   for security reasons as it contains filtering rules
# * other useful config files (like e.g nbconfig/notebook.json) can be shipped
#   in nbhosting's jupyter area, and in that case they serve as a default
#   which can this time be overridden by the course
#
# also on a temporary basis, we allow the old naming scheme, i.e.
# .nbhosting/nbconfig/notebook.json
#   is used if present as if it were in
# .nbhosting/jupyter/nbconfig/notebook.json
# and same for labconfig/default_setting_overrides.json

function --course-update-jupyter() {
    local USAGE="Usage: $COMMAND $FUNCNAME course"
    [ "$#" -eq 1 ] || -die $USAGE
    course=$1; shift
    -compute-course-globals $course
    [ -d $COURSE_jupyter ] || mkdir -p $COURSE_jupyter

    # temporary: start with the old names
    # the new names will take precedence
    function old-naming-scheme() {
        local path="$1"
        local oldfile=$COURSE_git/.nbhosting/$path
        local newfile=$COURSE_jupyter/$path
        if [[ -f $oldfile ]]; then
            local newdir=$(dirname $newfile)
            [[ -d $newdir ]] || mkdir -p $newdir
            cp $oldfile $newfile
        fi
    }
    old-naming-scheme nbconfig/notebook.json
    old-naming-scheme labconfig/default_setting_overrides.json

    # apply the 3 layers
    rsync -rltp $NBHROOT/jupyter/.template/ $COURSE_jupyter/
    # rsync the whole contents of the git repo
    if [[ -d $COURSE_git/.nbhosting/jupyter ]]; then
        rsync -rltp $COURSE_git/.nbhosting/jupyter/ $COURSE_jupyter/
    fi
    rsync -tp $NBHROOT/jupyter/.template/jupyter_notebook_config.py $COURSE_jupyter/
}


############################## unix accounts and containers
function -compute-student-globals-in-course () {

    local init_student_dir="true"
    while getopts "n" option; do
        case $option in
            n) init_student_dir="" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1


    student=$1; shift
    course=$1; shift
    STUDENT_home=$NBHROOT/students/$student
    STUDENT_course=$STUDENT_home/$course
    STUDENT_modules=$STUDENT_course/modules

    STUDENT_container="${course}-x-${student}"

    if [ -n "$init_student_dir" ]; then
        [ -d $STUDENT_course ] || sudo -u $student mkdir -p $STUDENT_course
    fi
}


# no need to expose this one
#@declare-subcommand add-student-in-course
function add-student-in-course() {
    local USAGE="Usage: $COMMAND $FUNCNAME student course"
    [ "$#" -eq 2 ] || -die $USAGE

    # typically of the form <course>-nnnnn
    local student=$1; shift
    # course name
    local course=$1; shift

    -echo-stderr $FUNCNAME $student $course - in $(pwd) as $(id)

    # create students root if not yet present
    [ -d $NBHROOT/students ] || mkdir -p $NBHROOT/students

    STUDENT_home=$NBHROOT/students/$student

    # when swapping back and forth between dev and prod
    # we may have a home dir already created  - by rsyncing data
    # during the swap - while the user in question is not yet known
    # in /etc/passwd; this is why we manage homedir creation explicitly
    #
    [ -d $STUDENT_home ] || {
        mkdir $STUDENT_home
    }

    # check login existence
    getent passwd $student >& /dev/null || {
        # default strategy is to create corresponding group
        local group_creation_option="--user-group"
        # in some rare conditions that group may already exist, use it then
        if getent group $student >& /dev/null; then
            group_creation_option="-g $student"
        fi
        -echo-stderr Creating disabled login $student
        useradd $group_creation_option --no-create-home --home-dir $STUDENT_home $student || {
            -echo-stderr Failed to create login $student - aborting;
            return 1
        }
        # disable login
        usermod -L $student
    }

    # always chown that homedir for safety
    chown -R $student:$student $STUDENT_home

    return 0

}


##########
# delete unix account
# xxx would need to properly stop/rm any attached container
# which might be easy if we use the same name for the student and the container
function del-student() {
    local USAGE="Usage: $COMMAND $FUNCNAME student"
    [ "$#" -eq 1 ] || -die $USAGE
    # the unix login name
    local student=$1; shift
    # xxx ...
    userdel --remove --force $student
}


# make sure the student has a copy of the nodebook
function -lazy-copy-student-notebook-for-course() {

    local forcecopy=""
    while getopts "f" option; do
        case $option in
            f) forcecopy="-f" ;;
            ?) -die "$USAGE" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    course=$1; shift
    student=$1; shift
    notebook="$1"; shift

    [ -n "$DEBUG" ] && set -x

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    local course_notebook=$COURSE_notebooks/"$notebook"
    local student_notebook=$STUDENT_course/"$notebook"

    # copy if student notebook is missing, or if force is requested
    if [ ! -f "$student_notebook" ] || [ -n "$forcecopy" ]; then
        -mkdir-for-file-as-student "$student_notebook" $student
        -echo-stderr "Cloning $student_notebook from $course_notebook (forcecopy=$forcecopy)"
        # use rsync for preserving creation time
        sudo -u $student rsync -tp "$course_notebook" "$student_notebook"
    else
        [ -n "$DEBUG" ] && -echo-stderr Student copy "$student_notebook" is fine
    fi

    # do this no matter what for easier deployment
    for mapping in $COURSE_static_mappings; do
        # expose() uses :: to separate
        local from_top=$(sed -e 's,::.*,,' <<< $mapping)
        local    local=$(sed -e 's,.*::,,' <<< $mapping)
        -create-symlink-at-file "$student_notebook" $local /home/jovyan/static/$from_top
    done

    [ -n "$DEBUG" ] && set +x

    # nothing else is required in the student's work area
    # the rest (modules/ for code, and static/)
    # will be bind-mounted in the container
}


function -git-repo-student-for-course() {
    local course="$1"; shift
    local giturl="$1"; shift
    local student=$1; shift

    -compute-course-globals $course
    # DON't (-n) create student dir if not present
    -compute-student-globals-in-course -n $student $course

    local toplevel=$STUDENT_course
    # not existing at all, the easy case
    if [ ! -d $toplevel ]; then
        sudo -u $student git clone $giturl $toplevel 1>&2
    elif [ ! -d $toplevel/.git ]; then
        -echo-stderr found student dir $toplevel without a .git needs rescue
        cd $toplevel
        sudo -u $student git clone $giturl . 1>&2
    # else we should be good;
    # however because of the change introduced in 0.21
    # when needed, we overwrite the 'origin' remote url
    # to point at the local directory under courses-git
    # instead of using the external git repo
    else
        cd $toplevel
        # some tracability, show only repos that need a change
        current_url=$(sudo -u $student git config remote.origin.url)
        if [ "$current_url" != "$giturl" ]; then
            -echo-stderr fixing remote.origin.url for 0.21 in $toplevel
            sudo -u $student git config remote.origin.url $giturl
        fi
    fi
}


########## port numbers
function free-port() {
    python3 << EOF
import socket
from contextlib import closing
with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
    s.bind(('', 0))
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    print(s.getsockname()[1])
EOF
}


####################
# the student is expected to have been created with enroll-student-in-course
# beforehand (so the unix account and homedir exists)
#
# after 0.24 the 2-stages allocation scheme
# (create and start) has been simplified
#
# possible resulting values for that phase (on stdout)
# * failed-* none none none
# * created container port jupyter-token
# * running container port jupyter-token
#
@declare-subcommand run-container-for-student-in-course
function run-container-for-student-in-course() {
    local USAGE="Usage: $COMMAND $FUNCNAME container student course image"

    [ "$#" -eq 4 ] || -die "$USAGE"

    # container name - if it exists then nothing happens here
    local container=$1; shift
    # student name aka student - should exist as $NBHROOT/students/$student
    local student=$1; shift
    # course name - should exist as $NBHROOT/courses/$course
    # i.e. should have gone through course-init and update-course
    local course=$1; shift
    # image name as known to podman
    local image="$1"; shift

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    # rain check
    [ -d $STUDENT_home ] || -die student dir not found $STUDENT_home
    [ -d $COURSE_nbroot ] || -die course notebooks dir not found $COURSE_nbroot
    [ -d $COURSE_modules ] || -echo-stderr WARNING $COURSE_modules dir not found
    for toplevel in $COURSE_toplevels; do
        local static_toplevel=$NBHROOT/static/$course/$toplevel
        [ -d $static_toplevel ] || -echo-stderr WARNING $static_toplevel dir not found
    done

    podman inspect --type image $image >& /dev/null || {
        echo failed-unknown-image $container none none
        -die image $image not known to podman;
    }

    # update jupyter_notebook_config.py and the 2 custom files
    -course-update-jupyter $course

    local jupyter_token=$container

    # check if container is known to podman
    if podman inspect --format "{{.Name}}" $container >& /dev/null ; then
        # if yes, check its status
        local status=$(podman inspect -f "{{.State.Status}}" $container)

        if [ "$status" == "removing" ]; then
            # out of luck here, we're trying to open a notebook
            # while monitor has just killed the container
            # tell the user to try again later
            echo failed-garbage-collecting $container none none
            return 1
        fi

        # sanity check mostly for smooth migration
        # on sites running a pre-0.24 version
        # the 'created' status has been observed only on transient
        # containers while troubleshooting podman runs hanging
        if [ "$status" != "running" -a "$status" != "created" ]; then
            # this has to be a sequel of nbhosting <= 0.23
            # as since 0.24 we run the containers with --rm
            # so as a temporary measure, we remove the container
            # so next time it will no longer be in the way
            -echo-stderr "removing container $container for compatibility"
            podman rm $container &
            echo failed-stopped-container $container none none
            return 1
        fi

        port=$(cat $STUDENT_course/.port)
        if [ -z "$port" ]; then
            echo failed-cannot-retrieve-port $container none none
            return 1
        fi

        # still need to wait for it; in classroom mode in particular
        # it is frequent that students quickly click on another notebook
        if ! -wait-for-http-on-port-token \
            $container $port $jupyter_token $timeout_wait_for_http; then
            # show podman logs on stderr
            -echo-stderr "==================== podman logs on that container over the last minute"
            >&2 podman logs -t --since +1m $container
            -echo-stderr "==================== podman logs end"
            echo failed-timeout $container $port existing
            return 1
        fi

        local line="existing $container $port $jupyter_token"
        echo $line
        return 0
    fi

    -echo-stderr Creating podman container $container
    # * map host free port to fixed 8888 in container
    # * bind mounts so that the user's data is on
    #   the host filesystem
    # * we mount the directory /home/jovyan/.jupyter as a whole
    #   instead as mounting the 2 files custom.js and custom.css individually
    #   this is an attempt to ease propagation of changes to any of these files
    #   as otherwise a container restart is required for this to take effect
    # * map jovyan uid to the student's;
    #   out of luck trying to use docker-stacks's native start.sh
    #   that led to costly and useless chown's on /opt/conda; so instead we
    #   * run the container as root
    #   * in turn use our own script start-in-dir-as-uid.sh
    #     from ../images that does runuser to have jupyter
    #     run as the right uid; of course this means it is a requirement
    #     for the course images to contain that script, hence the nbhosting/ images
    # * set NBAUTOEVAL_LOG to a file that ends up on the host filesystem the
    #   default for NBAUTOEVAL_LOG is $HOME/.nbautoeval, which in this context
    #   does not even make sense - $HOME is unset. Even if it was if would not
    #   reside on the host filesystem.

    # compute student uid
    STUDENT_uid=$(id -u $student)
    local port=$(free-port)
    # store it
    echo $port > $STUDENT_course/.port

    # this is really important on fedora-31, this variable somehow leaked from
    # systemd and caused podman run to stupidly hang
    unset NOTIFY_SOCKET
    # this one is to prevent the conmon process from being added in the systemd cgroup
    # https://github.com/containers/libpod/issues/6549
    unset INVOCATION_ID
    # mount the files under $COURSE_jupyter individually as ro
    # this way the container can create other files in this area
    MOUNTS=""
    for config in $(find $COURSE_jupyter -type f); do
        local basename=$(basename $file)
        local relpath=$(echo ${config} | sed -e "s|${COURSE_jupyter}||")
        MOUNTS="${MOUNTS} -v ${config}:/home/jovyan/.jupyter/${relpath}:ro"
    done
    command="podman run --name $container
                -p $port:8888
                --user root
                --rm --detach
                --memory=$container_max_memory
                --env NBAUTOEVAL_LOG=/home/jovyan/work/.nbautoeval
                $MOUNTS
                -v $STUDENT_course:/home/jovyan/work
                -v $COURSE_modules:/home/jovyan/modules:ro
                -v $COURSE_static:/home/jovyan/static:ro
                -v $COURSE_git:$COURSE_git:ro
                -e PYTHONPATH=/home/jovyan/modules
"

# for using jlab/git from inside a student container
# because NBHROOT and hence COURSE_git might be a symlink
# typically a student repo would have its remote set to
# remote.origin.url=/nbhosting/dev/courses-git/ue12-intro
# but only /nbhosting/current would be visible from the container
local course_GIT_norm=$(cd $COURSE_git; pwd -P)
[ "$course_GIT_norm" != "$COURSE_git" ] && \
    command="$command -v ${course_GIT_norm}:${course_GIT_norm}:ro"

# this one is for podman
    [ -n "$DEBUG" ] && command="$command --log-level=debug"
    # see start-in-dir-as-uid.sh for a note on setting the directories
    # below
    # note that setting the ip here is a workaround
    # for a broken jupyter/docker-stacks version around late 2018
    # probably not needed with more recent ones
    #
    # SECURITY notice: as of 2020 03 27, I replace
    #            --NotebookApp.token=$jupyter_token
    # with the last 3 settings below (token, password and disable_check_csrf)
    # so that recent chrome browsers with the new SameSite policy can
    # still open a notebook
    # it is clearly an example of when a change that aims at improving
    # security ends up being totally counter-productive, as I have been
    # unable so far to find a less aggressive way to make our users
    # get their service, but this approach is clearly way less secure than before...
    command="$command
                $image
                start-in-dir-as-uid.sh /home/jovyan $STUDENT_uid
                jupyter lab
                --ip=0.0.0.0
                --no-browser
                --NotebookApp.notebook_dir=/home/jovyan/work
                --NotebookApp.base_url=/$port/
                --NotebookApp.token=''
                --NotebookApp.password=''
                --NotebookApp.disable_check_xsrf=True
"
# this one id for jupyter
    [ -n "$DEBUG" ] && command="$command --log-level=DEBUG"
    # show command for manual debugging
    -echo-stderr container command: $command
    # we need a clean stdout : redirect stdout to stderr
    >&2 $command

    if ! -wait-for-http-on-port-token \
        $container $port $jupyter_token $timeout_wait_for_http; then
        # show podman logs on stderr
         -echo-stderr "==================== podman logs on that container over the last minute"
         >&2 podman logs -t --since +1m $container
         -echo-stderr "==================== podman logs end"
        echo failed-timeout $container $port created
        return 1
    fi

    local line="created $container $port $jupyter_token"
    [ -n "$DEBUG" ] && -echo-stderr $FUNCNAME writes line=$line
    echo $line
    return 0
}


function -wait-for-http-on-port-token() {
    local container=$1; shift
    local port=$1; shift
    local token=$1; shift
    local timeout=$1; shift
    local period=$1; shift
    local start=$(date +%s)
    local max=$(($start+$timeout))
    -echo-stderr "checking port against ss"
    ss --numeric --tcp --listening | egrep -q ":$port[ \t]"
    [ "$?" == 0 ] || -echo-stderr "OOPS - ss says port $port is busy !"
    while [ $(($(date +%s) <= $max)) == 1 ]; do
        # check that http is ready
        if ! timeout $period curl -s "http://localhost:$port/tree?token=$token" >& /tmp/wait-http-$port; then
            -echo-stderr "HTTP/$port down after $(($(date +%s)-$start))s"
            sleep $period
            continue
            podman inspect --format '{{.Name}}' $container >& /dev/null || echo "OOPS - $container is DEAD !!"
        else
            -echo-stderr "HTTP/$port up after $(($(date +%s)-$start))s"
            rm -f /tmp/wait-http-$port
            return 0
        fi
    done
    -echo-stderr "beg giving up on $port - last curl attempt yielded this :"
    >&2 cat /tmp/wait-http-$port
    rm -f /tmp/wait-http-$port
    -echo-stderr "end giving up on $port"
    return 1
}


# ENTRY POINT: this is the single entry point to edxfront.views in MOOC mode
# in classroom mode, we run this with the -g option so that a git repo
# gets created in the student's workspace

@declare-subcommand container-view-student-course-notebook
function container-view-student-course-notebook() {
    local USAGE="Usage: $COMMAND $FUNCNAME [-f] [-g] student course notebook image giturl"

    local forcecopy=""
    local init_student_git=""
    while getopts "fg" option; do
        case $option in
            f) forcecopy="-f" ;;
            g) init_student_git="true" ;;
            ?) -die "$USAGE" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    [ "$#" -eq 5 ] || -die $USAGE
    local student=$1; shift
    local course="$1"; shift
    local notebook="$1"; shift
    local image="$1"; shift
    local giturl="$1"; shift

    ## just in case is was never done before
    -check-course $course
    # update jupyter_notebook_config.py and the 2 custom files
    --course-update-jupyter $course

    ## in case the student is not known yet
    add-student-in-course $student $course || {
        # something wrong happened, typically /etc/login.defs misconfigured
        echo failed-cannot-add-student-in-course $student $course none
        return 1
    }

    ## create the student notebook if not there yet
    if [ -z "$init_student_git" ]; then
        -lazy-copy-student-notebook-for-course $forcecopy $course $student "$notebook"
    else
        -git-repo-student-for-course $course $giturl $student
    fi

    -compute-student-globals-in-course $student $course

    # create and start the container
    local container=$STUDENT_container
    # either existing of created
    run-container-for-student-in-course $container $student $course $image
}


# ENTRY POINT: another entrypoint to edxfront.views in classroom mode

@declare-subcommand container-view-student-course-jupyterdir
function container-view-student-course-jupyterdir() {
    local USAGE="Usage: $COMMAND $FUNCNAME [-f] student course image"

    [ "$#" -eq 3 ] || -die $USAGE
    local student=$1; shift
    local course=$1; shift
    local image=$1; shift

    ## just in case is was never done before
    -check-course $course
    # update jupyter_notebook_config.py and the 2 custom files
    --course-update-jupyter $course

    getent passwd $student >& /dev/null || {
        -echo-stderr "refusing to open jupyterdir session for unknown student $student"
        echo failed-unknown-student $student none none
        return 1
    }

    ## in case the student is not known yet
    add-student-in-course $student $course || {
        # something wrong happened, typically /etc/login.defs misconfigured
        echo failed-cannot-add-student-in-course $student $course none
        return 1
    }

    -compute-student-globals-in-course $student $course
    [ -d $STUDENT_course ] || {
        echo-stderr "refusing to open jupyterdir session for student $student"
        echo -stderr "who has not yet opened the $course course"
        echo failed-student-has-no-workdir $student $course none
        return 1
    }

    # create and start the container
    local container=$STUDENT_container
    # either existing of created
    run-container-for-student-in-course $container $student $course $image
}


#################### share a static version
# there here is the implicit assumption that the student
# has opened a private notebook at least once
#
# write a single line that is the path to use to reach the snapshot
#
@declare-subcommand container-share-student-course-notebook-in-hash
function container-share-student-course-notebook-in-hash() {
    local USAGE="Usage: $COMMAND $FUNCNAME student course notebook hash"
    [ "$#" -eq 4 ] || -die $USAGE
    local student=$1; shift
    local course=$1; shift
    local notebook="$1"; shift
    local hash=$1; shift
    local STUDENT_uid=$(id -u $student)

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    [ -n "$DEBUG" ] && set -x

    # host side -
    local host_notebook=$STUDENT_course/"$notebook"
    [ -f "$host_notebook" ] || -die "Student notebook not found in $host_notebook"

    # container side -
    local guest_notebook="work/$notebook"

    # the relative path for the http server (see nginx/nbhosting.conf)
    local url_path=/snapshots/$course/$hash.html
    # where to store the result in host
    local absolute_path=/var/nginx/nbhosting/$url_path
    -mkdir-for-file-as-student $absolute_path nginx

    $ENGINE exec $STUDENT_container \
        start-in-dir-as-uid.sh -s /home/jovyan $STUDENT_uid \
        /opt/conda/bin/jupyter nbconvert --to=html  --stdout "$guest_notebook" \
        > $absolute_path

    echo $url_path
}


#
# this will destroy any notebook in the workspace
# of any student declared as a staff member
# this is helpful so that all the staff always has
# the latest version, and does not see artefacts
# due to past activity; for example, imagine a notebook
# is renamed in git but there is a dangling reference in
# edx to the old name
#
@declare-subcommand course-clear-staff
function course-clear-staff() {
    local USAGE="Usage: $FUNCNAME course staff1 .. staffn"

    local course=$1; shift
    -compute-course-globals $course

    # 'student' is used by FUN's studio
    for staff in "$@" student; do
        -compute-student-globals-in-course $staff $course
        # xxx same here about using sitesettings.notebook_extensions
        notebooks=$(find $STUDENT_course -name '*.ipynb')
        if [ -z "$notebooks" ]; then
            echo "=== no notebook found in $STUDENT_course"
        else
            echo "Cleaning private notebooks in $STUDENT_course"
            for notebook in $notebooks; do
                echo '>>>' $notebook
            done
            rm -f $notebooks
        fi
    done
}


@declare-subcommand admin-list-kernels
function admin-list-kernels() {
    local USAGE="Usage: $FUNCNAME course [containers]"
    [ "$#" -ge 1 ] || -die $USAGE

    local course=$1; shift

    containers="$@"
    if [[ -z "$containers" ]]; then
        pattern="${course}-x-"
        containers=$($ENGINE ps \
                            --filter "name=$pattern" \
                            --format '{{.Names}}')
    fi
    for container in $containers; do
        port=$($ENGINE port $container | cut -d: -f2)
        echo ========== $container;
        curl -k --silent http://localhost:$port/api/kernels?token=$container | \
            python3 -c "import sys, pprint, json; pprint.pprint(json.loads(sys.stdin.read()))"
    done
}

####################

#@declare-subcommand list-courses
#function list-courses() {
#    local USAGE="Usage: $FUNCNAME"
#    [ "$#" -eq 0 ] || -die $USAGE
#
#    cd $NBHROOT/courses || exit 0
#    ls
#}


####################
function -rename-dir() {
    local oldname=$1; shift
    local newname=$1; shift
    [ -d $oldname ] || echo "SOURCE $oldname NOT FOUND"
    [ -d $newname ] && echo "DEST $newname FOUND"
    mv $oldname $newname
}

@declare-subcommand course-rename
function course-rename() {
    local USAGE="Usage: $FUNCNAME oldname newname"
    [ "$#" -eq 2 ] || -die $USAGE

    local old_course=$1; shift
    local new_course=$1; shift

    -compute-course-globals $old_course
    local old_git=$COURSE_git
    local old_notebooks=$COURSE_notebooks
    local old_modules=$COURSE_modules
    local old_static=$COURSE_static
    local old_jupyter=$COURSE_jupyter
    local old_raw=$COURSE_raw
    local old_image=$COURSE_image
    local old_build=$COURSE_build
    local old_droparea=$COURSE_droparea
    local old_local=$COURSE_local

    -compute-course-globals $new_course
    local new_git=$COURSE_git
    local new_notebooks=$COURSE_notebooks
    local new_modules=$COURSE_modules
    local new_static=$COURSE_static
    local new_jupyter=$COURSE_jupyter
    local new_raw=$COURSE_raw
    local new_image=$COURSE_image
    local new_build=$COURSE_build
    local new_droparea=$COURSE_droparea
    local new_local=$COURSE_local

    # check old_course is a known course
    [ -d $old_git ] || -die "Unknown course ${old_course}"
    # check new_course is not a known course
    [ -d $new_git ] && -die "Already existing course ${new_course}"

    # check all containers are down
    echo "Checking for remaining containers"
    local alive=$($ENGINE ps -a --format '{{.Names}}' | grep "^${old_course}-x" | wc -l)
    if [ $alive != 0 ]; then
        local message="Found $alive containers for $old_course"
        -die $message
    fi
    -rename-dir $old_git $new_git
    -rename-dir $old_notebooks $new_notebooks
    -rename-dir $old_modules $new_modules
    -rename-dir $old_static $new_static
    -rename-dir $old_jupyter $new_jupyter
    -rename-dir $old_raw $new_raw
    -rename-dir $old_image $new_image
    [ -d $old_build ] && -rename-dir $old_build $new_build
    [ -d $old_droparea ] && -rename-dir $old_droparea $new_droparea
    [ -d $old_local ] && -rename-dir $old_local $new_local

    for student_dir in $(echo $NBHROOT/students/*/$old_course); do
        local new_dir=$(sed -e "s,$old_course,$new_course," <<< $student_dir)
        -rename-dir $student_dir $new_dir
    done

}


############################## admin helpers

function count-containers() {
    echo ========== CONTAINERS
    local running=$($ENGINE ps | grep -v '^CONTAINER' | wc -l)
    local total=$($ENGINE ps -a | grep -v '^CONTAINER' | wc -l)
    echo "$running running / $total total containers"
}


function count-users() {
    echo ========== USERS and GROUPS
    local users=$(grep '^[^:]*:[^:]*:[0-9][0-9][0-9][0-9]' /etc/passwd | grep -v '^nfsnobody' | wc -l)
    local groups=$(grep '^[^:]*:[^:]*:[0-9][0-9][0-9][0-9]' /etc/group | egrep -v '^(nfsnobody|docker)' | wc -l)
    echo "$users users in /etc/passwd - $groups groups in /etc/group"
    set -x
    tail -1 /etc/subuid
    tail -1 /etc/subgid
    grep -v '^#' /etc/login.defs  | grep SUB_[UG]ID_MAX
    set +x
}


function count-tree() {
    echo ========== CONTENTS of $NBHROOT
    local students=$(ls $NBHROOT/students | wc -l)
    local courses_git=$(ls $NBHROOT/courses-git | wc -l)
    local courses=$(ls $NBHROOT/courses | wc -l)
    echo "$students students - $courses_git course repos - $courses actual courses"
    local logfiles=$(find $NBHROOT/logs -type f| wc -l)
    echo "$logfiles log files under $NBHROOT/logs"
    local rawfiles=$(find $NBHROOT/raw -type f| wc -l)
    echo "$rawfiles raw files under $NBHROOT/raw"
}


# provide some info on the various pieces
@declare-subcommand admin-counts
function admin-counts() {
    count-containers "$@"
    count-users "$@"
    count-tree "$@"
}


@declare-subcommand admin-container-enter
function admin-container-enter() {
    local USAGE="Usage: $FUNCNAME container"
    [ "$#" -eq 1 ] || -die $USAGE
    local container=$1; shift

    $ENGINE exec -ti $container /bin/bash
}


############################## devel/tests/-oriented

@declare-subcommand admin-container-kill-all
function admin-container-kill-all() {
    containers=$($ENGINE ps --format '{{.Names}}')
    for c in $containers; do
        echo "Killing $c"
        $ENGINE kill $c
    done
}


@declare-subcommand admin-container-rm-all
function admin-container-rm-all() {
    containers=$($ENGINE ps -a --format '{{.Names}}')
    for c in $containers; do
        echo "Removing $c"
        $ENGINE rm $c
    done
}


# we assume students hashes are 32 chars long
function clear-etc-passwd() {
    users=$(egrep '[0-9a-f]{32}' /etc/passwd | awk -F: '{print $1;}')
    for user in $users; do
        echo "Removing user $user from /etc/passwd"
        del-student $user
    done
}


# run on the box that is about to become the production box
function prepare-swap() {
    admin-container-kill-all
    admin-container-rm-all
    clear-etc-passwd
    echo "WARNING: this script does not take care of the courses area"
}


function list-tests() {
    echo ==================== "(all)" containers
    $ENGINE ps -a --format {{.Names}} | grep -- '-x-student-'
    echo ==================== users
    grep student- /etc/passwd
    echo ==================== user dirs
    ls -d $NBHROOT/students/student-* 2> /dev/null
}

function clear-tests() {
    for userdir in $(ls -d $NBHROOT/students/student-* 2>/dev/null); do
        user=$(basename $userdir)
        for coursedir in $(ls -d $userdir/* 2>/dev/null); do
            course=$(basename $coursedir)
            container=${course}-x-${user}
            $ENGINE inspect --type container $container >& /dev/null && {
                echo killing $container
                $ENGINE kill $container >& /dev/null
            }
            $ENGINE inspect --type container $container >& /dev/null && {
                echo removing $container
                $ENGINE rm $container >& /dev/null
            }
        done
        getent passwd $user >& /dev/null && {
            echo deleting user $user
            del-student $user
        }
        rm -rf $userdir
    done
}

# WARNING: this is for tests only
# the setting will be overridden by install.sh from the value
# specified in sitesettings.py
function test-set-monitor-idle() {
    local idle=$1; shift
    sed -i -e s"|--idle [0-9]*|--idle ${idle}|" /etc/systemd/system/nbh-monitor.service
    systemctl daemon-reload
    systemctl cat nbh-monitor.service
    systemctl restart nbh-monitor
}


######### main driver stub
USAGE="$COMMAND [-d nbhroot] [-x] subcommand ...
  -d  allows to set another root than $NBHROOT
  -x  turn on debugging
Available subcommands:
"

function list-subcommands() {
    for s in $SUBCOMMANDS; do
        echo $s
    done | sort | sed -e 's,^, * ,'
}

function usage() {
    printf "$USAGE"; list-subcommands;
}

function main() {

    while getopts "d:x" option; do
        case $option in
            d)  NBHROOT="$OPTARG"
                [[ "$NBHROOT" =~ /.* ]] || {
                # make sure root is absolute
                    NBHROOT=$(cd $NBHROOT; pwd -P)
                } ;;
            x) DEBUG=true-from-command-line ;;
            ?) >&2 usage; exit 1;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    load-sitesettings

    # first argument is a subcommand in this file
    local fun="$1"
    if [ -z "$fun" ]; then
        list-subcommands >& 2
        exit 1
    else
        case $(type -t -- $fun) in
            function)
                shift ;;
            *)
                { echo "$fun not a valid subcommand; pick among the following:"
                  list-subcommands
                  } >&2
                exit 1
                ;;
        esac
    fi

    # call subcommand
    -echo-stderr Starting $COMMAND $fun "$@"
    $fun "$@"
}


main "$@"
