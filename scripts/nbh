#!/bin/bash
# -*- mode: shell-script -*-
#
# group all shell commands in a single file
# you can run any of the inside functions with e.g.
#

# terminology
# (*) course refers to a course name as found under NBHROOT/courses
# (*) student refers to a UNIX login name, and is identical
# to the names used under NBHROOT when referring to a student
# (*) container is the name of a container as known to docker
#
# conventions
# (*) functions designed to be exposed to the outside
#     are declared with @declare-subcommand
# (*) some other minor subcommands are available
#     they start with a lowercase, but are not declared
#     as subcommands
# (*) internal-only functions start with a dash -
#
#
# NOTES about systemd-nspawn:
#
# (*) there remains in here some leftovers of a rough attempt
#     that I made at using systemd-nspawn as a replacement to docker
#     this was never finished, although we were probably close
#     all this was commented off in Jan. 2018
# (*) in this approach we still used docker but just for doing image
#     snapshots
# (*) the IMAGES and MACHINES globals are only used for this
#     systemd-nspawn variant, which was never finished
#     although we were probably close
# (*) missing was a suitable strategy for setuid
#     as linux user namespaces looks a little overkill
# (*) using the same approach to setuids as the one eventually
#     adopted for docker (i.e. start-in-dir-as-uid) should probably
#     be rather straightforward with systemd-nspawn too
#
# NOTE about interactions between shell and python
# sometimes we need to probe for data that is in the python world
# for this we use django management commands, that are accessible from
# the shell as /usr/bin/nbh-manage, which is a simple copy of django/manage.py
# although eventually for static definitions we've gone for good old files
# for a quicker and safer mechanism, logger was clobbering output
########################################

# nbh-driver
COMMAND=$0

# the default values for a few globals
NBHROOT=${NBHROOT:-/nbhosting/current}
DEBUG=

# miss options to tweak these - which relate to systemd-nspawn
#IMAGES=/homefs/btrfs/btrfs
#MACHINES=/homefs/btrfs/machines

### various timeouts
# format is ticks period
# so e.g. 10 0.3
# means 10s and retry every 300ms
#
# how long should we wait for the container to answer http
# trying to create 6 containers at the exact same time : 10s is not long enough
timeout_wait_for_http="30 .4"

# implementation note
#  don't do set -e, as it may cause the program to exit abruptly
# and we need to make sure we output exactly one line with 4 tokens

########## for listing available subcommands
SUBCOMMANDS=""
function @declare-subcommand() {
    subcommand=$1; shift
    SUBCOMMANDS="$SUBCOMMANDS $subcommand"
}

############################## helpers
function -echo-stderr() {
    local milli=$(date +"%N" | sed -e 's,\(...\).*,\1,')
    >&2 echo $(date "+%H:%M:%S").$milli "$@"
}

function -die() {
    -echo-stderr "$@"
    exit 1
}

function -keep-one-ipynb() {
    local incoming="$1"; shift
    sed -e 's/\(.ipynb\)\{2,\}/.ipynb/' <<< $incoming
}
########################################
# runtime
########################################

# create directory/ies leading to file <file>
function -mkdir-for-file-as-student () {
    [ "$#" -eq 2 ] || -die $FUNCNAME requires 2 args
    local filename="$1"; shift
    local login=$1; shift

    local dir=$(dirname "$filename")
    [ -d $dir ] || {
        -echo-stderr ID=$(id)
        -echo-stderr Creating directory $dir for "$filename"
        mkdir -p $dir
        -echo-stderr Giving $dir to $login
        chown $login:$login $dir
    }
}

# create symlink right where the notebook is, not only at the top
function -create-symlink-at-file () {
    [ "$#" -eq 3 ] || -die $FUNCNAME requires 3 args
    local filename="$1"; shift
    local localname="$1"; shift
    local destination="$1"; shift

    local dir=$(dirname "$filename")
    # the symlink should
    # be in dir/ (like filename)
    # be named localname
    # and point at destination
    local source="$dir/$localname"
    [ -h "$destination" ] || -echo-stderr creating static symlink "$destination"
    ln -sf "$destination" "$source"
}


############################## course management
function -compute-course-globals() {
    [ "$#" -eq 1 ] || -die $FUNCNAME requires 1 arg
    local course=$1; shift
    COURSE_git=$NBHROOT/courses-git/$course
    COURSE_notebooks=$NBHROOT/courses/$course
    COURSE_modules=$NBHROOT/modules/$course
    COURSE_static=$NBHROOT/static/$course
    COURSE_jupyter=$NBHROOT/jupyter/$course
    COURSE_raw=$NBHROOT/raw/$course
    COURSE_logs=$NBHROOT/logs/$course
    COURSE_build=$NBHROOT/images/$course
    COURSE_local=$NBHROOT/local/$course


#    # for systemd-nspawn
#    COURSE_ref=$MACHINES/$course.ref

# this is how the static mappings business is being exposed to bash
# from the django app    
    COURSE_static_mappings=$(cat $COURSE_notebooks/.static-mappings 2> /dev/null)
    COURSE_static_toplevels=$(cat $COURSE_notebooks/.static-toplevels 2> /dev/null)
}


# clone from upstream git repo
# and updates the various parts accordingly

@declare-subcommand course-init
function course-init() {
    local USAGE="Usage: $COMMAND $FUNCNAME course giturl"
    [ "$#" -eq 2 ] || -die $USAGE

    local course=$1; shift
    local giturl=$1; shift

    -compute-course-globals $course

    local log=$COURSE_logs/course-init.log

    function -course-init() {
        [ -d $COURSE_git ] && -die "Course already present as $COURSE_git"

        echo ==========  $(date): course-init from $giturl
        local courses_git_parent=$(dirname $COURSE_git)
        mkdir -p $courses_git_parent
        cd $courses_git_parent
        echo In $(pwd) : running git clone $giturl $course
        git clone $giturl $course
    }

    [ -d $COURSE_logs ] || mkdir -p $COURSE_logs
    -course-init >> $log 2>&1

}


##########
# pull from upstream git repo
# and updates the various parts accordingly
# also the options allow to change global settings
# for the course:
###
@declare-subcommand course-update-from-git
function course-update-from-git() {
    local USAGE="Usage: $COMMAND $FUNCNAME course"

    [ "$#" -eq 1 ] || -die $USAGE

    course=$1; shift
    -compute-course-globals $course

    local log=$NBHROOT/logs/$course/course-update.log

    # check the course is known
    [ -d $COURSE_git ] || -die "Cannot find git repo $COURSE_git"
    # initialize
    [ -d $COURSE_notebooks ] || {
        echo Creating notebooks dir $COURSE_notebooks
        mkdir -p $COURSE_notebooks
    }

    rsync="rsync --recursive --copy-unsafe-links --perms --times --force --delete"

    function -update-course() {

        [ -d $COURSE_git ] || -die "$FUNCNAME: $course has not git repo in $COURSE_git - aborting"

        echo ==========  $(date): update-course

        cd $COURSE_git
        echo "========== git pull"
        git pull
        # this does not always show 3 commits
        # so let's be more vague about that
        echo "========== latest commits"
        git log --oneline "HEAD~~~..HEAD"
        echo "========== dealing with submodules"
        # might not be exactly needed anymore if we use subtrees instead
        git submodule init
        git submodule update

        echo "========== housekeeping"
        # create course dirs if needed
        for dir in $COURSE_notebooks $COURSE_modules $COURSE_static $COURSE_raw; do
            [ -d $dir ] || { echo Creating $dir; mkdir -p $dir; }
        done

        # clear track caches
        rm -rf $COURSE_notebooks/.tracks.json

        ##### notebooks
        # temporary; making sure we do clean stuff up properly
        rm -rf $COURSE_notebooks/*
        $rsync --prune-empty-dirs --include='*.ipynb' --include='*.md' --include='*/' --exclude='*' \
            $COURSE_git/ $COURSE_notebooks/
        ##### modules
        [ -d modules ] && { $rsync modules/ $COURSE_modules; chmod -R g-w,o-w $COURSE_modules; }
        ##### static
        for toplevel in $COURSE_static_toplevels; do
            $rsync $toplevel $COURSE_static; chmod -R g-w,o-w $COURSE_static;
        done
        ##### jupyter
        [ -d $COURSE_jupyter ] || mkdir -p $COURSE_jupyter
        for file in jupyter_notebook_config.py custom.js custom.css; do
            [ -f $COURSE_jupyter/$file ] || touch $COURSE_jupyter/$file
        done
    }

    [ -d $COURSE_logs ] || mkdir -p $COURSE_logs
    -update-course 2> >(tee -a $log >&2)
}

####################
function -check-course() {
    local course=$1; shift
    -compute-course-globals $course
    [ -d $COURSE_notebooks ] || -die "No such course $course"
}


# a lot to say here:
# * it's unclear if we need to do the rsync here or not
#   some course might wish to provide their own custom*
# * the copy into a course-dependant location
#   looks extraneous but it might come in handy some day
# * finally this layout is painfully confusing..
#
function -check-course-jupyter() {
    local USAGE="Usage: $COMMAND $FUNCNAME course"
    [ "$#" -eq 1 ] || -die $USAGE
    course=$1; shift
    -compute-course-globals $course
    [ -d $COURSE_jupyter ] || mkdir -p $COURSE_jupyter
    # temporary : if we find a file named 'DETACHED' in $NBHROOT/jupyter/course/
    # then we leave that alone; otherwise, keep that in sync with our sources
    if [ -f $COURSE_jupyter/DETACHED ]; then
        -echo-stderr "Leaving jupyter material for $course intact (DETACHED found)"
    else
        for file in jupyter_notebook_config.py custom.js custom.css; do
            rsync -tp $NBHROOT/jupyter/$file $COURSE_jupyter/
        done
    fi
}


############################## unix accounts and containers
function -compute-student-globals-in-course () {

    local init_student_dir="true"
    while getopts "n" option; do
        case $option in
            n) init_student_dir="" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1


    student=$1; shift
    course=$1; shift
    STUDENT_home=$NBHROOT/students/$student
    STUDENT_course=$STUDENT_home/$course
    STUDENT_modules=$STUDENT_course/modules

    STUDENT_container="${course}-x-${student}"

    if [ -n "$init_student_dir" ]; then
        [ -d $STUDENT_course ] || sudo -u $student mkdir -p $STUDENT_course
    fi
}


# no need to expose this one
#@declare-subcommand add-student-in-course
function add-student-in-course() {
    local USAGE="Usage: $COMMAND $FUNCNAME student course"
    [ "$#" -eq 2 ] || -die $USAGE

    # typically of the form <course>-nnnnn
    local student=$1; shift
    # course name
    local course=$1; shift

    -echo-stderr $FUNCNAME $student $course - in $(pwd) as $(id)

    # create students root if not yet present
    [ -d $NBHROOT/students ] || mkdir -p $NBHROOT/students

    STUDENT_home=$NBHROOT/students/$student

    # when swapping back and forth between dev and prod
    # we may have a home dir already created  - by rsyncing data
    # during the swap - while the user in question is not yet known
    # in /etc/passwd; this is why we manage homedir creation explicitly
    #
    [ -d $STUDENT_home ] || {
        mkdir $STUDENT_home
    }

    # check login existence
    getent passwd $student >& /dev/null || {
        # default strategy is to create corresponding group
        local group_creation_option="--user-group"
        # in some rare conditions that group may already exist, use it then
        if getent group $student >& /dev/null; then
            group_creation_option="-g $student"
        fi
        -echo-stderr Creating disabled login $student
        useradd $group_creation_option --no-create-home --home-dir $STUDENT_home $student || {
            -echo-stderr Failed to create login $student - aborting;
            return 1
        }
        # disable login
        usermod -L $student
    }

    # always chown that homedir for safety
    chown -R $student:$student $STUDENT_home

    # add user to both groups docker and course
    for group in docker $course; do
        # check group existence
        getent group $group >& /dev/null || {
            -echo-stderr Creating group $group
            groupadd $group
        }
        -echo-stderr "Ensuring $student is in group $group"
        groupmems -a $student -g $group >& /dev/null
        # restarting docker would be way too intrusive !
        if [ $? != 0 -a "$group" == "docker" ]; then
            -echo-stderr "reloading docker service after adding $student into docker"
            systemctl reload docker
        fi
    done

    return 0

}


##########
# delete unix account
# xxx would need to properly stop/rm any attached container
# which might be easy if we use the same name for the student and the container
function del-student() {
    local USAGE="Usage: $COMMAND $FUNCNAME student"
    [ "$#" -eq 1 ] || -die $USAGE
    # the unix login name
    local student=$1; shift
    # xxx ...
    userdel --remove --force $student
}


# make sure the student has a copy of the nodebook
function -lazy-copy-student-notebook-for-course() {

    local forcecopy=""
    while getopts "f" option; do
        case $option in
            f) forcecopy="-f" ;;
            ?) -die "$USAGE" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    course=$1; shift
    student=$1; shift
    notebook="$1"; shift

    [ -n "$DEBUG" ] && set -x

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    local course_notebook=$COURSE_notebooks/"$notebook"
    local student_notebook=$STUDENT_course/"$notebook"

    # copy if student notebook is missing, or if force is requested
    if [ ! -f "$student_notebook" ] || [ -n "$forcecopy" ]; then
        -mkdir-for-file-as-student "$student_notebook" $student
        -echo-stderr "Cloning $student_notebook from $course_notebook (forcecopy=$forcecopy)"
        # use rsync for preserving creation time
        sudo -u $student rsync -tp "$course_notebook" "$student_notebook"
    else
        [ -n "$DEBUG" ] && -echo-stderr Student copy "$student_notebook" is fine
    fi

    # do this no matter what for easier deployment
    for mapping in $COURSE_static_mappings; do
        # expose() uses :: to separate
        local from_top=$(sed -e 's,::.*,,' <<< $mapping)
        local    local=$(sed -e 's,.*::,,' <<< $mapping)
        -create-symlink-at-file "$student_notebook" $local /home/jovyan/static/$from_top
    done

    [ -n "$DEBUG" ] && set +x

    # nothing else is required in the student's work area
    # the rest (modules/ for code, and static/)
    # will be bind-mounted in the docker container
}


function -git-repo-student-for-course() {
    local course="$1"; shift
    local giturl="$1"; shift
    local student=$1; shift

    -compute-course-globals $course
    # DON't (-n) create student dir if not present
    -compute-student-globals-in-course -n $student $course

    local toplevel=$STUDENT_course
    # not existing at all, the easy case
    if [ ! -d $toplevel ]; then
        sudo -u $student git clone $giturl $toplevel 1>&2
    elif [ ! -d $toplevel/.git ]; then
        -echo-stderr found student dir $toplevel without a .git needs rescue
        cd $toplevel
        sudo -u $student git clone $giturl . 1>&2
    # else we should be good;
    # however because of the change introduced in 0.21
    # when needed, we overwrite the 'origin' remote url 
    # to point at the local diretory under courses-git
    # instead of using the external git repo
    else
        cd $toplevel
        # some tracability, show only repos that need a change
        current_url=$(sudo -u $student git config remote.origin.url)
        if [ "$current_url" != "$giturl" ]; then
            -echo-stderr fixing remote.origin.url for 0.21 in $toplevel
            sudo -u $student git config remote.origin.url $giturl
        fi
    fi
}


########## port numbers
function free-port() {
    python3 << EOF
import socket
from contextlib import closing
with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
    s.bind(('', 0))
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    print(s.getsockname()[1])
EOF
}


####################
# the student is expected to have been created with enroll-student-in-course
# beforehand (so the unix account and homedir exists)
#
# after 0.24 the 2-stages allocation scheme
# (create and start) has been simplified
#
# possible resulting values for that phase (on stdout)
# * failed-* none none none
# * created container port jupyter-token
# * running container port jupyter-token
#
@declare-subcommand docker-run-container-for-student-in-course
function docker-run-container-for-student-in-course() {
    local USAGE="Usage: $COMMAND $FUNCNAME container student course image"

    [ "$#" -eq 4 ] || -die "$USAGE"

    # container name - if it exists then nothing happens here
    local container=$1; shift
    # student name aka student - should exist as $NBHROOT/students/$student
    local student=$1; shift
    # course name - should exist as $NBHROOT/courses/$course
    # i.e. should have gone through course-init and update-course
    local course=$1; shift
    # image name as known to docker
    local image="$1"; shift

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    # rain check
    [ -d $STUDENT_home ] || -die student dir not found $STUDENT_home
    [ -d $COURSE_nbroot ] || -die course notebooks dir not found $COURSE_nbroot
    [ -d $COURSE_modules ] || -echo-stderr WARNING $COURSE_modules dir not found
    for toplevel in $COURSE_toplevels; do
        local static_toplevel=$NBHROOT/static/$course/$toplevel
        [ -d $static_toplevel ] || -echo-stderr WARNING $static_toplevel dir not found
    done

    docker inspect --type image $image >& /dev/null ||\
        -die image $image not known to docker

    # update jupyter_notebook_config.py and the 2 custom files
    -check-course-jupyter $course

    local jupyter_token=$container

    # check if container is known to docker
    if docker inspect --format "{{.Name}}" $container >& /dev/null ; then
        # if yes, check its status
        local status=$(docker inspect -f "{{.State.Status}}" $container)
        
        if [ "$status" == "removing" ]; then
            # out of luck here, we're trying to open a notebook
            # while monitor has just killed the container
            # tell the user to try again later
            echo failed-garbage-collecting $container none none
            return 1
        fi

        # sanity check mostly for smooth migration
        # on sites running a pre-0.24 version
        if [ "$status" != running ]; then
            # this has to be a sequel of nbhosting <= 0.23
            # as since 0.24 we run the containers with --rm
            # so as a temporary measure, we remove the container
            # so next time it will no longer be in the way
            docker rm $container &
            echo failed-stopped-container $container none none
            return 1
        fi

        port=$(cat $STUDENT_course/.port)
        if [ "$running" != true ]; then
            echo failed-cannot-retrieve-port $container none none
            return 1
        fi

        local line="existing $container $port $jupyter_token"
        [ -n "$DEBUG" ] && -echo-stderr $FUNCNAME writes line=$line
        echo $line
        return 0
    fi

    -echo-stderr Creating docker container $container
    # * map host free port to fixed 8888 in container
    # * bind mounts so that the user's data is on
    #   the host filesystem
    # * we mount the directory /home/jovyan/.jupyter as a whole
    #   instead as mounting the 2 files custom.js and custom.css individually
    #   this is an attempt to ease propagation of changes to any of these files
    #   as otherwise a container restart is required for this to take effect
    # * map jovyan uid to the student's
    #   out of luck trying to use docker-stacks's native start.sh
    #   that led to costly and useless chown's on /opt/conda; so instead we
    #   * run the container as root
    #   * in turn use our own script start-in-dir-as-uid.sh
    #     from ../docker/images that does runuser to have jupyter
    #     run as the right uid; of course this means it is a requirement
    #     for the course images to contain that script
    # * turn off this http header that otherwise would prevent
    #   embedding in a FUN iframe
    #   Content-Security-Policy: frame-ancestors 'self';
    #        ... report-uri /api/security/csp-report
    #   so set the web server's settings to clear the
    #   Content-Security-Policy header it is too tedious on the command line
    #   with quoting and all, so we use jupyter's config file instead in
    #   jupyter/jupyter_notebook_config.py
    # * set NBAUTOEVAL_LOG to a file that ends up on the host filesystem the
    #   default for NBAUTOEVAL_LOG is $HOME/.nbautoeval, which in this context
    #   does not even make sense - $HOME is unset. Even if it was if would not
    #   reside on the host filesystem.

    # compute student uid
    STUDENT_uid=$(id -u $student)
    local port=$(free-port)
    # store it
    echo $port > $STUDENT_course/.port

    # -d is for running in background (detached) mode
    command="docker run -d --name $container
                --publish published=8888,target=$port
                --user root
                --rm
                --env NBAUTOEVAL_LOG=/home/jovyan/work/.nbautoeval
                -v $STUDENT_course:/home/jovyan/work
                -v $COURSE_jupyter/jupyter_notebook_config.py:/home/jovyan/.jupyter/jupyter_notebook_config.py:ro
                -v $COURSE_jupyter:/home/jovyan/.jupyter/custom:ro
                -v $COURSE_modules:/home/jovyan/modules:ro
                -v $COURSE_static:/home/jovyan/static:ro
                -v $COURSE_git:$COURSE_git:ro
"
    # see start-in-dir-as-uid.sh for a note on setting the directories
    # below
    # note that setting the ip here is a workaround
    # for a broken jupyter/docker-stacks version around late 2018
    # probably not needed with more recent ones
    command="$command
                -e PYTHONPATH=/home/jovyan/modules
                $image
                start-in-dir-as-uid.sh /home/jovyan $STUDENT_uid
                jupyter notebook
                --ip=0.0.0.0
                --no-browser
                --NotebookApp.notebook_dir=/home/jovyan/work
                --NotebookApp.token=$jupyter_token
                --NotebookApp.base_url=/$port/
"

    [ -n "$DEBUG" ] && command="$command --log-level=DEBUG"
    # show command for manual debugging
    -echo-stderr container command: $command
    # we need a clean stdout : redirect stdout to stderr
    >&2 $command

    if ! -wait-for-http-on-port-token \
        $container $port $jupyter_token $timeout_wait_for_http; then
        # show docker logs on stderr
         -echo-stderr "==================== docker logs on that container over the last minute"
         >&2 docker logs -t --since +1m $container
         -echo-stderr "==================== docker logs end"
        echo failed-timeout $container $port none
        return 1 
    fi

    local line="created $container $port $jupyter_token"
    [ -n "$DEBUG" ] && -echo-stderr $FUNCNAME writes line=$line
    echo $line
    return 0
}


function -wait-for-http-on-port-token() {
    local container=$1; shift
    local port=$1; shift
    local token=$1; shift
    local timeout=$1; shift
    local period=$1; shift
    local start=$(date +%s)
    local max=$(($start+$timeout))
    -echo-stderr "checking port agains ss"
    ss --numeric --tcp --listening | egrep -q ":$port[ \t]"
    [ "$?" == 0 ] || -echo-stderr "OOPS - ss says port $port is busy !"
    while [ $(($(date +%s) <= $max)) == 1 ]; do
        # check that http is ready
        if ! timeout $period curl -s "http://localhost:$port/tree?token=$token" >& /tmp/wait-http-$port; then
            -echo-stderr "HTTP/$port down after $(($(date +%s)-$start))s"
            sleep $period
            continue
            docker inspect --format '{{.Name}}' $container >& /dev/null || echo "OOPS - $container is DEAD !!"
        else
            -echo-stderr "HTTP/$port up after $(($(date +%s)-$start))s"
            return 0
        fi
    done
    -echo-stderr "beg giving up on $port - last curl attempt yielded this :"
    >&2 cat /tmp/wait-http-$port 
    -echo-stderr "end giving up on $port"
    return 1
}


# ENTRY POINT: this is the single entry point to edxfront.views in MOOC mode
# in classroom mode, we run this with the -g option so that a git repo
# gets created in the student's workspace

@declare-subcommand docker-view-student-course-notebook
function docker-view-student-course-notebook() {
    local USAGE="Usage: $COMMAND $FUNCNAME [-f] [-g] student course notebook image giturl"

    local forcecopy=""
    local init_student_git=""
    while getopts "fg" option; do
        case $option in
            f) forcecopy="-f" ;;
            g) init_student_git="true" ;;
            ?) -die "$USAGE" ;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    [ "$#" -eq 5 ] || -die $USAGE
    local student=$1; shift
    local course="$1"; shift
    local notebook="$1"; shift
    local image="$1"; shift
    local giturl="$1"; shift

    ## just in case is was never done before
    -check-course $course
    # update jupyter_notebook_config.py and the 2 custom files
    -check-course-jupyter $course

    ## in case the student is not known yet
    add-student-in-course $student $course || {
        # something wrong happened, typically /etc/login.defs misconfigured
        echo failed-cannot-add-student-in-course $student $course none
        return 1
    }

    ## create the student notebook if not there yet
    if [ -z "$init_student_git" ]; then
        -lazy-copy-student-notebook-for-course $forcecopy $course $student "$notebook" 
    else
        -git-repo-student-for-course $course $giturl $student 
    fi

    -compute-student-globals-in-course $student $course

    # create and start the container
    local container=$STUDENT_container
    # either existing of created
    docker-run-container-for-student-in-course $container $student $course $image
}


# ENTRY POINT: another entrypoint to edxfront.views in classroom mode

@declare-subcommand docker-view-student-course-jupyterdir
function docker-view-student-course-jupyterdir() {
    local USAGE="Usage: $COMMAND $FUNCNAME [-f] student course image"

    [ "$#" -eq 3 ] || -die $USAGE
    local student=$1; shift
    local course=$1; shift
    local image=$1; shift

    ## just in case is was never done before
    -check-course $course
    # update jupyter_notebook_config.py and the 2 custom files
    -check-course-jupyter $course

    getent passwd $student >& /dev/null || {
        -echo-stderr "refusing to open jupyterdir session for unknown student $student"
        echo failed-unknown-student $student none none
        return 1
    }

    ## in case the student is not known yet
    add-student-in-course $student $course || {
        # something wrong happened, typically /etc/login.defs misconfigured
        echo failed-cannot-add-student-in-course $student $course none
        return 1
    }

    -compute-student-globals-in-course $student $course
    [ -d $STUDENT_course ] || {
        echo-stderr "refusing to open jupyterdir session for student $student"
        echo -stderr "who has not yet opened the $course course"
        echo failed-student-has-no-workdir $student $course none
        return 1
    }

    # create and start the container
    local container=$STUDENT_container
    # either existing of created
    docker-run-container-for-student-in-course $container $student $course $image
}


#################### share a static version
# there here is the implicit assumption that the student
# has opened a private notebook at least once
#
# write a single line that is the path to use to reach the snapshot
#
@declare-subcommand docker-share-student-course-notebook-in-hash
function docker-share-student-course-notebook-in-hash() {
    local USAGE="Usage: $COMMAND $FUNCNAME student course notebook hash"
    [ "$#" -eq 4 ] || -die $USAGE
    local student=$1; shift
    local course=$1; shift
    local notebook=$(-keep-one-ipynb "$1"); shift
    local hash=$1; shift

    -compute-course-globals $course
    -compute-student-globals-in-course $student $course

    [ -n "$DEBUG" ] && set -x

    # host side -
    local host_notebook=$STUDENT_course/"$notebook"
    [ -f "$host_notebook" ] || -die "Student notebook not found in $host_notebook"

    # container side -
    local guest_notebook="work/$notebook"

    # the relative path for the http server (see nginx/nbhosting.conf)
    local url_path=/snapshots/$course/$hash.html
    # where to store the result in host
    local absolute_path=/var/nginx/nbhosting/$url_path
    -mkdir-for-file-as-student $absolute_path nginx

    docker exec $STUDENT_container \
        jupyter nbconvert --to html  --stdout "$guest_notebook" \
        > $absolute_path

    echo $url_path
}


#
# this will destroy any notebook in the workspace
# of any student declared as a staff member
# this is helpful so that all the staff always has
# the latest version, and does not see artefacts
# due to past activity; for example, imagine a notebook
# is renamed in git but there is a dangling reference in
# edx to the old name
#
@declare-subcommand course-clear-staff
function course-clear-staff() {
    local USAGE="Usage: $FUNCNAME course staff1 .. staffn"

    local course=$1; shift
    -compute-course-globals $course

    # 'student' is used by FUN's studio
    for staff in "$@" student; do
        -compute-student-globals-in-course $staff $course
        notebooks=$(find $STUDENT_course -name '*.ipynb')
        if [ -z "$notebooks" ]; then
            echo "=== no notebook found in $STUDENT_course"
        else
            echo "Cleaning private notebooks in $STUDENT_course"
            for notebook in $notebooks; do
                echo '>>>' $notebook
            done
            rm -f $notebooks
        fi
    done
}


#
# once a course is over it is safe to remove all containers
# attached to that course
#
# NOTES:
# * because dockerd handles one request at a time
#   and so effectively sequentialize all these destruction requests
#   this is likely to take hours or even days..
# * also the way to locate containers is based on the course name
#   in a somewhat inclusive way; it can be a bit inaccurate if I
#   have for instance 2 courses python and thepython
#   but only stopped containers will be removed
#   so it is not too big a deal
# * by default, only containers that have exited
#   more than one month ago are removed
#   with the -a option, all such containers are removed

@declare-subcommand admin-docker-rm-course-containers
function admin-docker-rm-course-containers() {
    local USAGE="Usage: $FUNCNAME course"
    [ "$#" -eq 1 ] || -die $USAGE
    local course=$1; shift
    local pattern="${course}-x-"
    while true; do
        local focus=$(docker ps -a \
            --filter 'status=exited' \
            --filter "name=$pattern" \
            --format '{{.Names}}' \
            | head -1)
        # we're done
        [ -z "$focus" ] && break
        # otherwise remove it
        #echo $FUNCNAME removing container $focus
        docker rm $focus
    done
}


@declare-subcommand admin-docker-list-kernels
function admin-docker-list-kernels() {
    local USAGE="Usage: $FUNCNAME course [containers]"
    [ "$#" -ge 1 ] || -die $USAGE

    local course=$1; shift

    containers="$@"
    if [[ -z "$containers" ]]; then
        pattern="${course}-x-"
        containers=$(docker ps \
                            --filter "name=$pattern" \
                            --format '{{.Names}}')
    fi
    for container in $containers; do
        port=$(docker port $container | cut -d: -f2)
        echo ========== $container;
        curl -k --silent http://localhost:$port/api/kernels?token=$container | \
            python3 -c "import sys, pprint, json; pprint.pprint(json.loads(sys.stdin.read()))"
    done
}

####################

@declare-subcommand list-courses
function list-courses() {
    local USAGE="Usage: $FUNCNAME"
    [ "$#" -eq 0 ] || -die $USAGE

    cd $NBHROOT/courses || exit 0
    ls
}


####################
function -rename-dir() {
    local oldname=$1; shift
    local newname=$1; shift
    [ -d $oldname ] || echo "SOURCE $oldname NOT FOUND"
    [ -d $newname ] && echo "DEST $newname FOUND"
    mv $oldname $newname
}

@declare-subcommand course-rename
function course-rename() {
    local USAGE="Usage: $FUNCNAME oldname newname"
    [ "$#" -eq 2 ] || -die $USAGE

    local old_course=$1; shift
    local new_course=$1; shift

    -compute-course-globals $old_course
    local old_git=$COURSE_git
    local old_notebooks=$COURSE_notebooks
    local old_modules=$COURSE_modules
    local old_static=$COURSE_static
    local old_jupyter=$COURSE_jupyter
    local old_raw=$COURSE_raw
    local old_logs=$COURSE_logs
    local old_build=$COURSE_build
    local old_local=$COURSE_local

    -compute-course-globals $new_course
    local new_git=$COURSE_git
    local new_notebooks=$COURSE_notebooks
    local new_modules=$COURSE_modules
    local new_static=$COURSE_static
    local new_jupyter=$COURSE_jupyter
    local new_raw=$COURSE_raw
    local new_logs=$COURSE_logs
    local new_build=$COURSE_build
    local new_local=$COURSE_local

    # check old_course is a known course
    [ -d $old_git ] || -die "Unknown course ${old_course}"
    # check new_course is not a known course
    [ -d $new_git ] && -die "Already existing course ${new_course}"

    # check all containers are down
    echo "Checking for remaining containers"
    local alive=$(docker ps -a --format '{{.Names}}' | grep "^${old_course}-x" | wc -l)
    if [ $alive != 0 ]; then
        local message="Found $alive containers for $old_course"
        message="$message - Delete with nbh admin-docker-rm-course-containers"
        -die $message
    fi
    -rename-dir $old_git $new_git
    -rename-dir $old_notebooks $new_notebooks
    -rename-dir $old_modules $new_modules
    -rename-dir $old_static $new_static
    -rename-dir $old_jupyter $new_jupyter
    -rename-dir $old_raw $new_raw
    -rename-dir $old_logs $new_logs
    -rename-dir $old_build $new_build
    [ -d $old_local ] && -rename-dir $old_local $new_local

    for student_dir in $(echo $NBHROOT/students/*/$old_course); do
        local new_dir=$(sed -e "s,$old_course,$new_course," <<< $student_dir)
        -rename-dir $student_dir $new_dir
    done

}


############################## admin helpers

function count-docker() {
    echo ========== CONTAINERS
    local running=$(docker ps | grep -v '^CONTAINER' | wc -l)
    local total=$(docker ps -a | grep -v '^CONTAINER' | wc -l)
    echo "$running running / $total total containers"
}


function count-users() {
    echo ========== USERS and GROUPS
    local users=$(grep '^[^:]*:[^:]*:[0-9][0-9][0-9][0-9]' /etc/passwd | grep -v '^nfsnobody' | wc -l)
    local groups=$(grep '^[^:]*:[^:]*:[0-9][0-9][0-9][0-9]' /etc/group | egrep -v '^(nfsnobody|docker)' | wc -l)
    echo "$users users in /etc/passwd - $groups groups in /etc/group"
    set -x
    tail -1 /etc/subuid
    tail -1 /etc/subgid
    grep -v '^#' /etc/login.defs  | grep SUB_[UG]ID_MAX
    set +x
}


function count-tree() {
    echo ========== CONTENTS of $NBHROOT
    local students=$(ls $NBHROOT/students | wc -l)
    local courses_git=$(ls $NBHROOT/courses-git | wc -l)
    local courses=$(ls $NBHROOT/courses | wc -l)
    echo "$students students - $courses_git course repos - $courses actual courses"
    local logfiles=$(find $NBHROOT/logs -type f| wc -l)
    echo "$logfiles log files under $NBHROOT/logs"
    local rawfiles=$(find $NBHROOT/raw -type f| wc -l)
    echo "$rawfiles raw files under $NBHROOT/raw"
}


# provide some info on the various pieces
@declare-subcommand admin-counts
function admin-counts() {
    count-users "$@"
    count-docker "$@"
    count-tree "$@"
}


@declare-subcommand admin-docker-enter
function admin-docker-enter() {
    local USAGE="Usage: $FUNCNAME container"
    [ "$#" -eq 1 ] || -die $USAGE
    local container=$1; shift

    docker exec -ti $container /bin/bash
}


############################## devel/tests/-oriented

@declare-subcommand admin-docker-kill-all
function admin-docker-kill-all() {
    containers=$(docker ps --format '{{.Names}}')
    for c in $containers; do
        echo "Killing $c"
        docker kill $c
    done
}


@declare-subcommand admin-docker-rm-all
function admin-docker-rm-all() {
    containers=$(docker ps -a --format '{{.Names}}')
    for c in $containers; do
        echo "Removing $c"
        docker rm $c
    done
}


# we assume students hashes are 32 chars long
function clear-etc-passwd() {
    users=$(egrep '[0-9a-f]{32}' /etc/passwd | awk -F: '{print $1;}')
    for user in $users; do
        echo "Removing user $user from /etc/passwd"
        del-student $user
    done
}


# run on the box that is about to become the production box
function prepare-swap() {
    admin-docker-kill-all
    admin-docker-rm-all
    clear-etc-passwd
    echo "WARNING: this script does not take care of the courses area"
}


function list-tests() {
    echo ==================== "(all)" dockers
    docker ps -a --format {{.Names}} | grep -- '-x-student-'
    echo ==================== users
    grep student- /etc/passwd
    echo ==================== user dirs
    ls -d $NBHROOT/students/student-* 2> /dev/null
}

function clear-tests() {
    for userdir in $(ls -d $NBHROOT/students/student-* 2>/dev/null); do
        user=$(basename $userdir)
        for coursedir in $(ls -d $userdir/* 2>/dev/null); do
            course=$(basename $coursedir)
            docker=${course}-x-${user}
            echo killing $docker
            docker kill $docker >& /dev/null
            echo removing $docker
            docker rm $docker >& /dev/null
        done
        echo deleting user $user
        del-student $user
    done
}


######### main driver stub
USAGE="$COMMAND [-d nbhroot] [-x] subcommand ...
  -d  allows to set another root than $NBHROOT
  -x  turn on debugging
Available subcommands:
"

function list-subcommands() {
    for s in $SUBCOMMANDS; do
        echo $s
    done | sort | sed -e 's,^, * ,'
}

function usage() {
    printf "$USAGE"; list-subcommands;
}

function main() {

    while getopts "d:x" option; do
        case $option in
            d) NBHROOT="$OPTARG"
               # make sure root is absolute
               NBHROOT=$(cd $NBHROOT; pwd -P)
               ;;
            x) DEBUG=true ;;
            ?) >&2 usage; exit 1;;
        esac
    done
    shift $((OPTIND-1))
    # reset OPTIND for subsequent calls to getopts
    OPTIND=1

    # first argument is a subcommand in this file
    local fun="$1"
    if [ -z "$fun" ]; then
        list-subcommands >& 2
        exit 1
    else
        case $(type -t -- $fun) in
            function)
                shift ;;
            *)
                { echo "$fun not a valid subcommand; pick among the following:"
                  list-subcommands
                  } >&2
                exit 1
                ;;
        esac
    fi

    # call subcommand
    -echo-stderr Starting $COMMAND $fun "$@"
    $fun "$@"
}


main "$@"
